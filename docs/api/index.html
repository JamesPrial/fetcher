<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Model Catalog API</title>
</head>
<body>
    <script>
        // API Query Handler for AI Model Catalog
        // Supports URL parameters for filtering and querying model data

        const API_VERSION = '1.0.0';

        // Parse URL parameters
        function getQueryParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                provider: params.get('provider'),
                capability: params.get('capability'),
                search: params.get('search'),
                min_context: params.get('min_context') ? parseInt(params.get('min_context')) : null,
                max_context: params.get('max_context') ? parseInt(params.get('max_context')) : null,
                min_prompt_price: params.get('min_prompt_price') ? parseFloat(params.get('min_prompt_price')) : null,
                max_prompt_price: params.get('max_prompt_price') ? parseFloat(params.get('max_prompt_price')) : null,
                min_completion_price: params.get('min_completion_price') ? parseFloat(params.get('min_completion_price')) : null,
                max_completion_price: params.get('max_completion_price') ? parseFloat(params.get('max_completion_price')) : null,
                supports_vision: params.get('supports_vision'),
                supports_function_calling: params.get('supports_function_calling'),
                supports_streaming: params.get('supports_streaming'),
                format: params.get('format') || 'json',
                limit: params.get('limit') ? parseInt(params.get('limit')) : null,
                offset: params.get('offset') ? parseInt(params.get('offset')) : 0,
                sort: params.get('sort') || 'name',
                order: params.get('order') || 'asc'
            };
        }

        // Convert string to boolean
        function toBool(value) {
            if (value === null) return null;
            return value.toLowerCase() === 'true' || value === '1';
        }

        // Filter models based on query parameters
        function filterModels(models, params) {
            let filtered = [...models];

            // Provider filter
            if (params.provider) {
                const providers = params.provider.toLowerCase().split(',');
                filtered = filtered.filter(m => providers.includes(m.provider.toLowerCase()));
            }

            // Capability filters
            const capability = params.capability;
            if (capability) {
                const capabilities = capability.toLowerCase().split(',');
                filtered = filtered.filter(m => {
                    return capabilities.every(cap => {
                        switch (cap) {
                            case 'vision':
                                return m.capabilities?.supports_vision === true;
                            case 'function-calling':
                            case 'function_calling':
                                return m.capabilities?.supports_function_calling === true;
                            case 'streaming':
                                return m.capabilities?.supports_streaming === true;
                            default:
                                return true;
                        }
                    });
                });
            }

            // Individual capability filters
            const visionFilter = toBool(params.supports_vision);
            if (visionFilter !== null) {
                filtered = filtered.filter(m => m.capabilities?.supports_vision === visionFilter);
            }

            const functionCallingFilter = toBool(params.supports_function_calling);
            if (functionCallingFilter !== null) {
                filtered = filtered.filter(m => m.capabilities?.supports_function_calling === functionCallingFilter);
            }

            const streamingFilter = toBool(params.supports_streaming);
            if (streamingFilter !== null) {
                filtered = filtered.filter(m => m.capabilities?.supports_streaming === streamingFilter);
            }

            // Search filter
            if (params.search) {
                const searchTerm = params.search.toLowerCase();
                filtered = filtered.filter(m => {
                    const searchableText = `${m.name} ${m.model_id} ${m.description || ''}`.toLowerCase();
                    return searchableText.includes(searchTerm);
                });
            }

            // Context length filters
            if (params.min_context !== null) {
                filtered = filtered.filter(m => m.context_length >= params.min_context);
            }
            if (params.max_context !== null) {
                filtered = filtered.filter(m => m.context_length <= params.max_context);
            }

            // Price filters (per-token pricing)
            if (params.min_prompt_price !== null) {
                filtered = filtered.filter(m => m.pricing?.prompt >= params.min_prompt_price);
            }
            if (params.max_prompt_price !== null) {
                filtered = filtered.filter(m => m.pricing?.prompt && m.pricing.prompt <= params.max_prompt_price);
            }
            if (params.min_completion_price !== null) {
                filtered = filtered.filter(m => m.pricing?.completion >= params.min_completion_price);
            }
            if (params.max_completion_price !== null) {
                filtered = filtered.filter(m => m.pricing?.completion && m.pricing.completion <= params.max_completion_price);
            }

            return filtered;
        }

        // Sort models
        function sortModels(models, sortBy, order) {
            const sorted = [...models];
            sorted.sort((a, b) => {
                let aVal, bVal;

                switch (sortBy) {
                    case 'name':
                        aVal = a.name.toLowerCase();
                        bVal = b.name.toLowerCase();
                        return order === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                    case 'provider':
                        aVal = a.provider.toLowerCase();
                        bVal = b.provider.toLowerCase();
                        return order === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                    case 'context':
                    case 'context_length':
                        aVal = a.context_length || 0;
                        bVal = b.context_length || 0;
                        return order === 'asc' ? aVal - bVal : bVal - aVal;
                    case 'prompt_price':
                    case 'prompt-price':
                        aVal = a.pricing?.prompt || Infinity;
                        bVal = b.pricing?.prompt || Infinity;
                        return order === 'asc' ? aVal - bVal : bVal - aVal;
                    case 'completion_price':
                    case 'completion-price':
                        aVal = a.pricing?.completion || Infinity;
                        bVal = b.pricing?.completion || Infinity;
                        return order === 'asc' ? aVal - bVal : bVal - aVal;
                    case 'updated':
                    case 'updated_at':
                        aVal = new Date(a.updated_at);
                        bVal = new Date(b.updated_at);
                        return order === 'asc' ? aVal - bVal : bVal - aVal;
                    default:
                        return 0;
                }
            });
            return sorted;
        }

        // Apply pagination
        function paginate(models, limit, offset) {
            if (limit === null) return models;
            return models.slice(offset, offset + limit);
        }

        // Convert to CSV
        function toCSV(models) {
            const headers = [
                'model_id',
                'name',
                'provider',
                'context_length',
                'prompt_price',
                'completion_price',
                'supports_vision',
                'supports_function_calling',
                'supports_streaming',
                'description'
            ];

            const escapeCSV = (value) => {
                if (value === null || value === undefined) return '';
                const str = String(value);
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    return '"' + str.replace(/"/g, '""') + '"';
                }
                return str;
            };

            const rows = models.map(m => [
                escapeCSV(m.model_id),
                escapeCSV(m.name),
                escapeCSV(m.provider),
                escapeCSV(m.context_length || ''),
                escapeCSV(m.pricing?.prompt || ''),
                escapeCSV(m.pricing?.completion || ''),
                escapeCSV(m.capabilities?.supports_vision ? 'true' : 'false'),
                escapeCSV(m.capabilities?.supports_function_calling ? 'true' : 'false'),
                escapeCSV(m.capabilities?.supports_streaming ? 'true' : 'false'),
                escapeCSV(m.description || '')
            ].join(','));

            return [headers.join(','), ...rows].join('\n');
        }

        // Output response
        function outputResponse(data, format, totalCount = null) {
            const isArray = Array.isArray(data);

            if (format === 'csv') {
                // Output as CSV
                const models = isArray ? data : (data.models || []);
                document.body.innerHTML = '<pre>' + toCSV(models) + '</pre>';
                document.body.style.fontFamily = 'monospace';
            } else {
                // Output as JSON
                const response = isArray ? {
                    api_version: API_VERSION,
                    total_count: totalCount !== null ? totalCount : data.length,
                    count: data.length,
                    models: data
                } : {
                    api_version: API_VERSION,
                    ...data
                };

                document.body.innerHTML = '<pre>' + JSON.stringify(response, null, 2) + '</pre>';
                document.body.style.fontFamily = 'monospace';
            }
        }

        // Show API documentation
        function showDocumentation() {
            const docs = {
                api_version: API_VERSION,
                title: 'AI Model Catalog API',
                description: 'Query and filter AI model information from multiple providers',
                base_url: window.location.origin + window.location.pathname,
                endpoints: {
                    'GET /api/': {
                        description: 'Query models with filtering, sorting, and pagination',
                        parameters: {
                            provider: 'Filter by provider (comma-separated). Example: openai,anthropic',
                            capability: 'Filter by capability (comma-separated). Values: vision, function-calling, streaming',
                            search: 'Search in model name, ID, or description',
                            min_context: 'Minimum context length (integer)',
                            max_context: 'Maximum context length (integer)',
                            min_prompt_price: 'Minimum prompt price per token (float)',
                            max_prompt_price: 'Maximum prompt price per token (float)',
                            min_completion_price: 'Minimum completion price per token (float)',
                            max_completion_price: 'Maximum completion price per token (float)',
                            supports_vision: 'Filter by vision support (true/false)',
                            supports_function_calling: 'Filter by function calling support (true/false)',
                            supports_streaming: 'Filter by streaming support (true/false)',
                            sort: 'Sort field. Values: name, provider, context, prompt-price, completion-price, updated',
                            order: 'Sort order. Values: asc, desc (default: asc)',
                            limit: 'Number of results to return (pagination)',
                            offset: 'Number of results to skip (pagination, default: 0)',
                            format: 'Output format. Values: json, csv (default: json)'
                        }
                    },
                    'GET /api/providers/': {
                        description: 'List all available providers',
                        example: window.location.origin + '/fetcher/api/providers/'
                    },
                    'GET /api/providers/{provider}.json': {
                        description: 'Get all models from a specific provider (pre-generated)',
                        examples: [
                            window.location.origin + '/fetcher/api/providers/openai.json',
                            window.location.origin + '/fetcher/api/providers/anthropic.json'
                        ]
                    },
                    'GET /api/capabilities/{capability}.json': {
                        description: 'Get all models with a specific capability (pre-generated)',
                        examples: [
                            window.location.origin + '/fetcher/api/providers/vision.json',
                            window.location.origin + '/fetcher/api/providers/function-calling.json'
                        ]
                    },
                    'GET /api/stats.json': {
                        description: 'Get summary statistics',
                        example: window.location.origin + '/fetcher/api/stats.json'
                    }
                },
                examples: [
                    {
                        description: 'Get all OpenAI models with vision support',
                        url: '?provider=openai&supports_vision=true'
                    },
                    {
                        description: 'Search for GPT-4 models',
                        url: '?search=gpt-4'
                    },
                    {
                        description: 'Get models with context > 100k, sorted by price',
                        url: '?min_context=100000&sort=prompt-price&order=asc'
                    },
                    {
                        description: 'Get cheapest models with function calling',
                        url: '?supports_function_calling=true&sort=prompt-price&order=asc&limit=10'
                    },
                    {
                        description: 'Export Anthropic models as CSV',
                        url: '?provider=anthropic&format=csv'
                    }
                ]
            };

            outputResponse(docs, 'json');
        }

        // Main API handler
        async function handleRequest() {
            try {
                const params = getQueryParams();

                // If no parameters, show documentation
                if (window.location.search === '') {
                    showDocumentation();
                    return;
                }

                // Load models data
                const response = await fetch('../models.json');
                if (!response.ok) {
                    throw new Error('Failed to load models data');
                }

                const data = await response.json();
                let models = data.models || [];

                // Apply filters
                models = filterModels(models, params);

                // Store total count before pagination
                const totalCount = models.length;

                // Apply sorting
                models = sortModels(models, params.sort, params.order);

                // Apply pagination
                models = paginate(models, params.limit, params.offset);

                // Output response
                outputResponse(models, params.format, totalCount);

            } catch (error) {
                const errorResponse = {
                    api_version: API_VERSION,
                    error: error.message,
                    status: 'error'
                };
                document.body.innerHTML = '<pre>' + JSON.stringify(errorResponse, null, 2) + '</pre>';
                document.body.style.fontFamily = 'monospace';
                document.body.style.color = '#ef4444';
            }
        }

        // Run on page load
        handleRequest();
    </script>
</body>
</html>
